Things to know{
    class,method def
    runtime error and compile time errors with examples
    Methods of object class.
}

Intro{
    Java can be used for mobile developement, Web developement and Enterprice developement

    Java is a strictly typed language.

}

Questions
{
    What kind of error will be thrown if the main method is not found in the Java program? Runtime Error

    Which subsystem of the JVM is responsible for loading class files? ClassLoader

    What kind of error will be thrown if the main method is not found in the Java program? Convestion of data from lower to higher data types.
    
    default value assigned to boolean is False.

    class Main
    {

        public static void main(String []args){

        char ch = 'a';

        char result = (char)(ch + 1);

        System.out.println(result);

        }

    }
    ans is b.

    What does a high-order bit represent for an integer?Sign of the integer

    What will happen if a local variable has the same name as an instance variable within a class? Local variable will hide the instance variable.

    (Ref\45.png)(Ref\Box.java)

    (Ref\46.png)(Ref\Patient.java)
}

Compiler{
    file name and class name can be different but while compiling you should enter file name then it will create .class file of class name and u should run with the class name.(Compile with file name, Run with class name)

    Compiler Just checks only syntax
}

JDK,JRE,JVM (PPT\1.png){
    JDK converts ur code to bite code
    JVM runs the code
    JVM and the extra libraries,in-built classes etc.. that we have used in our code combined called JRE(Java Run Time Environment)
    JVM is a part of JRE

    JVM is an abstract, it is not physically exist
    Java is platform independent but JVM  is platform dependent

    We have a machine to make java Platform independent we went for a virtual layer doesn't matter which machine u have JVM the idea is to have JVM on every machine
}

Public Static Void Main (String args[]){
    Public - Public it is a access modifier, JVM should be able to call this method out side of the class.
    Static- Creating Space, it is the 1st one to load, it allows to call without creating a object of a class in which a main method is defined.
    Void- Doesn't return any value.
    Main - Main method is static.
    Main method is statcu because object is not created but still it is loaded

    if the method is static no need of ref variable u can directly call that method like (Ref\1.png).
    if you are making a non static method without reference u cannot access.So to make that happen we have to make a referece of that class and then  call the method with that referece that we created. (Ref\2.png)

    String args[] is arguments that we pass in main method.
    args is just a name u acn keep anything there. (Ref\3.png)
    arguments passes in String type.
    args[] is a array type variable which we can call as object of string.
    We use this String args[] when we want to pass information, even if we dont want to pass information we should include because it is a part of syntax.
}

javap{
    To see the source code u can enter javap (classname). (Ref\4.png)
    it is also called as java dissabmler.
}

Stack and Heap Memory{
    
    In JVM you have 2 types of memory 1.Stack Memory(1st in-last out) 2.Heap Memory. (Ref\5.png) 
    Stack Store memory in Key(name of the variable) and Value(value of the variable). (Ref\6.png)
    Check this. (Ref\7.2.png)line20 is not object it is a referece variable.So when we say new Claculator it will create a new object inside the heap memory. 
    Local variables are a part of a Stack,Instace variables are a part of Heap.
    Even the add method also sotres in Heap(it actually sotres the definition of add), but the actuall area that add will consume is Stack Memory. (Ref\8.png) 
    And that address of the object that created in heap memory is stored in the front of obj. (Ref\9.png)
    So that we can say there is a link between stack and heap, it will search for the add
}

Instance Varibles{
    Check this. (PPT\3.png)
}

Memory Occupied by differernt variables{
    Check this. (PPT\4.png)
    instance variables allocated in memory heap.
}

Local Variables{
    Check this. (PPT\2.png)
    Check this. (PPT\5.png)
}

Static Varibles{
    Check this. (PPT\6.png)
    We can change the value of static variable i.e it will take the updated value. (PPT\7.png)for ans check output only
}

Wrapper Classes means converting primitive into object and object into primitive{
    int --> Integer
    char --> Character
    long --> Long
    autoboxing-->primitive to object
    unboxing --> object to primitive
}

Datatypes {
    (Ref\10.png)
}

null{
    means the reference refers to nothing.
    Null is just value that a reference which is basically restricting a pointer.
}

Points{
    Character can be incremented by using integer (Ref\11.png)
    literals are the values that are given to the variables
}

% operator{
    if the numerator is smaller than the denominator it will always give the value of numerator.
}

Type Casting{
    If it is happening automatically it is converting.
    Doing is Explicitly it is Casting.
    Implicit TypeConversion - Small to Big. 
    Explicit TypeCasting - Big to Small.
    We cannot store Character value into Boolean value, Because Boolean supports only True and False.
    From int to byte it will perform Modulus of that num by 256 and give remainder as output.
    Java supports type promotions i.e; it the result is out of byte it will promote it to integer. (Ref\12.png)
    Check this.(Ref\13.png) it behaves differently when u try to assign/fetch a value to it 
}

Ternary Operator {
    Check this(Ref\14.png)
}

Switch Case:{
    To not to use break statements we can use arrow or yelid (Ref\17.png)(Ref\16.png)
    Using switch case as expression (Ref\15.png)
}

Post and Pre increment{
    Check this (Ref\18.png).
}

While loop{ 
    loops till it returns false(while loops return ture or false)
    it runs till the condition is false
}

Do-While 
{
    will always excecute once either the condition is true or false.
    So if we want the loop to excecute atleast once then we can use this loop.
    end the loop with semicolon(;).
    in the do block u should include increment or decrement operator or else it will go to infinite loop.
}

for{
    to use for loop as while loop u can use two semicolon's(Ref\19.png)
}

Which loop to use{
    if you know how many iteration you want to run then you can use For loop
    if you want to read a file or database u can use while loop.
    if u want the loop to run atleast once then u can use do while loop
}

void{
    void is used when ur  not expecting in return of that method
}

return{
    if the codes see's return in any part of the code it will jump out out the code and return the value and it will stop the excecution of that method
}

Method overloading{
    only parameter's should be diff, diff return type will not work.
    We can overload main method also.
}

Array{
    Array is a collection of homogenous or similar datatypes.
    Length of array is defined whn it is created once created it is fixed we cannot change it.
    Check this (Ref\20.png)(Ref\21.png)(Ref\22.png)(Ref\23.png)(PPT\8.png)(PPT\9.png)(PPT\10.png)(PPT\11.png)(PPT\12.png)(PPT\13.png)(PPT\14.png)[(PPT\15.png)in second line"[[" means 2d array I means Integer ].
    Anonymus array Check this(Ref\24.png).

    What does arr[arr.length-1].length represents in a multidimensional array? length of last row in the array

    Jagged array(Ref\29.png)
    3D array(Ref\30.png)

    Array it is having fixedsize so to fix it u can craete new array of new length and copy that elements.
}

System.in{
    System.in in Scanner line is standard input object 
}

new keyword{
    the new keyword allocate memory for an object during runtime in Java.
}

Strings{
    Check this(Ref\25.png)(Ref\26.png)(Ref\27.png)(Ref\28.png)
    String is a class So to create it we need to do something similar to object creation. String name= new String("HI"); but u can do the normal way also even that will create a object for u. 

    String constant pool where it stores same Strings like s1="Teja", s2="Teja" here it will not create a new objcet for u. it will use the address of s1. to save memory.
    but if u do s="Sree"; s=s+"Teja"; then will will create a new object and it will allocate new address to it and the old one will be removed by garbage collection after sometime.(Ref\31.png)
    
    Strings are Immutable
    but u can use String buffer and string builder classes to create a mutable string
    String Immutable{
        Check this(PPT\16.png)
        Check this (Ref\38.png)
        Check this(PPT\17.png)
    }
    String class is Final (PPT\18.png)
    == and equalsto() are diff{
        Check this.(PPT\19.png)
        (Ref\39.png) output is equal.(because here it is in string constant pool)
        (Ref\40.png) output is not equal.(but here we are creating 2 new objects)
        (Ref\41.png) output is equal.
    }    

}

StringBuffer and StringBuilder{
    Check this(PPT\20.png)
    String buffer have 16bytes extra space even if u create a literal it will have 16+that literal size.(Ref\32.png)
    length and capacity are different
    we can convert string buffer to string using toString method.

    Diff btwn 3 Check this(Ref\42.png)

    String buffer is thread safe, stringbuilder is not thread safe.
}

equals method{
    it is used to compare the reference or address of 2 objects
    but in String class it will extend Object class and override equals method and use it for content comparision.
}

Math.random(){
    method in Java returns a double value.
}

Range: {
    The returned value is a pseudorandom number between 0.0 (inclusive) and 1.0 (exclusive).
}

Mutable and Immutable{
    Mutable means Changable
    Immutable means Unchangable
}

Diffferent type of Variables{
    Variable inside the method are local variable.
    Outside the method are instance variable.
    Static variable (outside method) if u want that value to be same for all then u can use static key word in fornt of that variable.
    (Ref\33.png)Here even we are changing the value of phone using on ref variable obj1 it is changing for both the obj's 
    Static variables should be called with the class name instead of obj u can call with the obj also but not adviced.
    In non static methods u can use static variables.
}

Different type of Methods{
    Methods without static key word are called instance methods.
    When ever u want to work with a non static methods we need to create obj of it so we can call static method directly with the help of the class name.
    we can use static variable inside a static method but u cant use non static variable. because it will change for every variable and obj that we refernced to it.where as static variables are same.but we can use it if u have the object reference we can use it.(Ref\34.png)
    That is the reason why main method is static, if the main method is not static we have to create a obj of that class. but main method is the 1st execution part in the code so that's the deadlock here.
}

Class{
    Check this.(PPT\21.png)
}

Method{
    Check this.(PPT\22.png)
}

Object{
    Check this(PPT\23.png)
    Check this(PPT\24.png)
    Check this(PPT\25.png)
    Intialize object by method (PPT\26.png)(Ref\44.png)
    Intializing object by ref variable (Ref\43.png)
}

Static Block{
    Check this(Ref\35.png) in the out put it will print static 1st and constructor 2 times
    every time u create a object it will load the class 1st and objects are instantiated.
    the thing is class will be loaded once.
    JVM will have a special area named class loader it will have all the classes loaded.So when the 1st obj created it will load the class 1st and then the obj is created.So every time u load a class it will call the static block(Class loads only once so static block is also called once.)   
    if you dont create the obj it not not call the class as well.(didn't get)
    but u can do it by using Class.forName("nameoftheclass i.e, mobile")
}

Encapsulation{
    Privte key word used for a varible means it can be used only insde that class no one outside it cant use.
    use getter and setter methods
    So to access it we can create a new method and return that private vaariable in the same class then u can call that method and acess that using obj.
    Check this(Ref\36.png)
}

this keyword{
    this is a keyword that represents the current object.(current object means the object that is calling the method)(Ref\Demo.java)
}

Constructor{
    A constructor/Default Constructor looks like a method.
    but no return type, name is same as class name[(Human) (capital)] also specify the access i.e, public.
    even if u dont call it, it will be called.
    Every time u create a object it will call the constructor.Even if there is no construtor created by u 
    U can assign ur own default values.
    Database connections are written in the constructor.
    Parameterized Constructor means constructor having parameter that are comming form the obj creation. (Ref\D2.java)
}
Anonymous Object{
    Objects without name. {new A();}
    we cannot re-use them
}

Inhertence{
    for inheritence u need a .class file not .java file.
    Reason why java dosen't support multiple inheritence is because it let say we have 3 classes A,B,C C is child and A,B are parents let say if both A and B have same methods and now when u create a object and try to call the method the java will be confused becasue it dont know who's method to use.
}

Super and this methods{
    by default every constructor will have super.
    Super means call the constructor of the super class.
    Every class in java extends Object class by default.
    this will excute the constructor of the same class.
    execution order this(),super();
}

Method Overriding{
    same name, same parameters and same number of parameters but have differet behaviour.(Ref\D3.java)
}

Access Modifiers{
    public means it can be used anywhere
    private means it can be used inside the same class irrespective of the package
    Default means private protected
    Check this(Ref\37.png)
    Points to remember{
        u cannot have 2 public classes in same file
        try to keep instance variables private 
        methods most of the time would be public
        if u want a method or variable used only in sub class of other packages then use protected 
        try to avoid default
    }
}

Polymorphyism{
    Many behaviours.
    Compile time(Early binding),Runtime(Late binding)
    behaviour is defined at Compile time it is CT
    behaviour defined at Runtime it is RT 
    Overloading us a part of compiletime(which u decide based on ur parameter at the compile time itself)
    Overriding is a part of  runtime (we are not sure which method we will call becasue both will have same parameters)
}

Dynamic method Dispatch{
    U can have child objects for the parent variable.
    Check this.(Ref\D4.java)

}

Final Keyword{
    the moment u make your variable final the variable becomes constant.
    if u make the class final u are stopping in heritence,that means u cannot inherit the final class.
    when u want to override u r method over ride u can make that method public final.
    Check this(Ref\D5.java)

}

Object class equals tostring hashcode{
    Every time u try to print object it will call tostring method.
    to string method returns getClass().getName() @ Integer.toHextString(hashCode())
    Hashing is creating a single variable with all the data that u have.
    So to get the integer value in place of hashcode u can override the method toString by returning the integer variable there.
    Check this(Ref\D6.java)
}

Upcasting adnd Downcasting{
    it is similar to type casting but it is done in diff classes with their objects.(i.e, u can create a parent reference with child object)
    Upcasting can be done implicitly (automatically) 
    Referering parent to child object is called upcasting 
    Downcasting u have to do manually
    Creating reference of child and parent object is called Downcasting
}

Wrapper Classes{
    Primitive Dataypes dont extend object class.
    for every primitive type we are going to have class for it and that class extends object class
    autoboxing means primitive type to object type.
    unboxing object type to primitive type.

}

Abstract{
    if u want to just declare a method u should use abstract 
    abstract method can belong only to abstract class
    So after decalring the abstract method in the abstract classs now u will extend that class in another class and define that abstract method.
    U cannot create an object of an abstract class
    U can create a reference of a abstract class
    if u wannt to create an object u have to use the child class where u have defined that abstract method.
    Abstract class need not have abstract method.
    But abstract methods can't be left unimplemented they should be implemented i.e, it is compulsory to define all the abstract methods(to make it work u have to make even the child class abstract,but then u cannot create object of abstract class )
    Non abstract classes are called concrete class.
    U can create object of contrete class but not abstract class.
}

Inner Class{
    Class inside class which have methods.
    if u compile the code u will get 3 .class files 1 Main class file 2 A class and 3 inner class B with like this A$B.class  
    So to declare the varible of B u have to declare like this A.B obj1;
    but when u say A.B obj1= new B(); it wont work.
    So to create obj of B u need obj of A i.e A.B  obj1= new obj.B();[obj is a object of A]
    but if B is a static class then u can create obj like A.B obj1 = new A.B();
    Only inner classes can be static. 
    Outer classes cannot be static.
}

Anonymous Inner Class{
    class without name.
    implementation is done after object creation there there wont be any name to that class so it is called anonymous class.
    (Ref\D7.java)    here it will call the show() of the new implementation
    We can use anonymous inner class for abstract class as well.
    Check this(Ref\D8.java).
}

